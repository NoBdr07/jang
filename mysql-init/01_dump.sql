CREATE DATABASE  IF NOT EXISTS `jang` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;
USE `jang`;
-- MySQL dump 10.13  Distrib 8.0.38, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: jang
-- ------------------------------------------------------
-- Server version	8.4.0

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `questions`
--

DROP TABLE IF EXISTS `questions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `questions` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `level` int NOT NULL,
  `title` varchar(255) NOT NULL,
  `answer` varchar(5000) NOT NULL,
  `topic_id` int NOT NULL,
  PRIMARY KEY (`id`),
  KEY `topic_id_idx` (`topic_id`),
  CONSTRAINT `topic_id` FOREIGN KEY (`topic_id`) REFERENCES `topics` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=118 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `questions`
--

LOCK TABLES `questions` WRITE;
/*!40000 ALTER TABLE `questions` DISABLE KEYS */;
INSERT INTO `questions` VALUES (1,1,'Quels sont les principaux codes HTTP ?','-  200: success -  201 : object created -  400 : bad request -  401 : unauthorized -  403 : forbidden -  404 : not found -  500 : internal server error',1),(2,1,'Qu’est ce que l’IoC ?','-  Inversion of control -  Design pattern -  Au lieu que la classe appelle directement ses dépendances ou les instancie, un framework ou conteneur le fait à sa place.',1),(5,1,'Qu’est ce que l’OOP ?','OOP (Object-Oriented Programming) ou programmation orientée objet est un paradigme de programmation qui organise le code autour de classes et objets.',2),(6,1,'Quels sont les principes de l’OOP ?','-  Encapsulation (classe = data + méthodes) -  Abstraction (utilisation de classe abstraite, interface) -  Heritage (classe peut hériter d’une autre) -  Polymorphisme (même méthode peut avoir plusieurs comportements).',2),(7,1,'Qu’est ce qu’une interface ?','-  Définit un ensemble de méthodes sans fournir leur implémentation.',2),(8,1,'Quelle différence entre une classe abstraite et une interface ?','Classe abstraite  Interface Peut avoir méthodes abstraites et  Que méthodes abstraites concrètes Pas d’attribut, seulement constantes Peut avoir des attributs Contrat que plusieurs classes peuvent Une seule classe parente possible  implémenter  Base pour une sous-classe qui l’étend  Une classe peut implémenter plusieurs interface',2),(9,1,'Qu’est-ce qu’un design pattern ?','Un modèle de conception, solution éprouvée à des problème courants.',2),(10,1,'Quels sont les design pattern en Java ?','-  De création (création d’objets) : o  Singleton : classe a qu’une seule instance o  Factory : créer objets sans exposer logique d’instanciation o  Builder : facilite la création d’objets complexes -  Structurel (organisation classes et objets) : o  Adapter : rend compatible deux classes o  Decorator : ajoute des fonctionnalités à un objet -  Comportementaux (interaction entre objets) : o  Observer : notifier objets quand event se produit o  Strategy : changer d’algorithme dynamiquement',2),(11,1,'Qu’est ce que SOLID ?','SOLID est un ensemble de cinq principes pour améliorer la conception du code orienté objet : -  SRP (Single Responsibility Principle) : Une classe doit avoir une seule responsabilité. -  OCP (Open/Closed Principle) : Les classes doivent être ouvertes à l\'extension, mais fermées à la modification. -  LSP (Liskov Substitution Principle) : Les sous-classes doivent être interchangeables avec leurs classes de base sans altérer le comportement. -  ISP (Interface Segregation Principle) : Les interfaces doivent être spécifiques et ne pas forcer les classes à implémenter des méthodes inutiles. -  DIP (Dependency Inversion Principle) : Les classes doivent dépendre d\'abstractions, pas de détails concrets. Ces principes rendent le code plus modulaire, réutilisable et facile à maintenir.  En Angular, qu’est ce que le CDD ? -  Component Driven Development -  Concevoir application à partir de composants indépendants et réutilisables avant même de penser à l’assemblage global -  Avantages : réutilisabilité, testabilité, performance, scalabilité.',3),(12,1,'Qu’est ce que Java ?','Java est un langage de programmation de haut niveau, orienté objet et basé sur les classes. Il a été conçu pour être portable, grâce à la compilation du code source en bytecode, exécuté par la Java Virtual Machine (JVM), quel que soit le système d’exploitation.',3),(13,1,'Quelles sont les principales avancées pour chaque version ?','-  8 : Streams, Optional, lambda, java.time. -  9 : modules. -  11 : execution directe de fichiers .java, HttpClient stable -  17 : sealed class, simplification syntaxe des Switch -  21 : virtual threads, Record Patterns, String templates.  Expliquer ce que sont la JVM, JRE et JDK. -  JVM (Java Virtual Machine) : exécute le bytecode Java -  JRE (Java Runtime Environment) : contient la JVM + les bibliothèques nécessaires à l’exécution des applications Java. -  JDK (Java Development Kit) : contient le JRE + les outils de développement (ex : javac, javadoc) pour compiler et développer du code Java.',3),(14,1,'Pourquoi Java est-il un langage indépendant de la plateforme ?','Java est indépendant de la plateforme grâce à la JVM (Java Virtual Machine). Le code Java est compilé en bytecode, qui n’est pas lié à un système d’exploitation spécifique. Ce bytecode peut être exécuté sur n’importe quelle machine disposant d’une JVM compatible. C’est le principe \"Write Once, Run Anywhere\" : écrire le code une seule fois, l’exécuter partout.',3),(15,1,'Qu’est ce que le transtypage en Java ?','-  = casting -  Conversion d’une variable d’un type à un autre -  2 types : elargissant/implicite, reducteur/explicite. ',3),(16,1,'Qu’est ce qu’un constructeur en Java ?','-  Code appelé quand une instance est crée -  Même nom que la classe',3),(17,1,'Qu’est ce que le mot “super” en Java ?','Référence à un objet de la classe parent.',3),(18,1,'Quels sont les types d’exceptions ?','-  Checked (vérifiées) = doivent être gérées par un try-catch ou déclarées par un throws. -  Unchecked (non-verifiées) = héritent de RuntimeException et ne nécessite pas de gestion.',3),(19,1,'Quelle différence entre exception et erreur ?','-  Exception = liée aux erreurs de logique -  Erreur = défaillance système ou JVM',3),(20,1,'Quelle différence entre throw et throws ?','-  Throw : lance une exception -  Throws : déclare qu’une méthode peut potentiellement lever une exception.',3),(21,1,'Pourquoi Java n’est pas purement orienté object ?','Car les types primitifs ne sont pas des objets.',3),(22,1,'Qu’est ce qu’une wrapper class ?','-  Encapsule un type primitif dans un objet -  Permet d’utiliser ces types là où un objet est attendu -  Fournit des méthodes utilitaires',3),(23,1,'Qu’est ce que l’autoboxing et l’unboxing ?','-  Autoboxing : type primitif -> object wrapper -  Unbonxing : wrapper -> primitif',3),(24,1,'Qu’est ce qu’un thread ?','Flux d’execution indépendant au sein d’un programme.',3),(25,1,'A quoi sert “synchronized” ?','-  Pour qu’un seul thread à la fois puisse exécuter un bloc de code -  Pour éviter les problèmes de concurrence (race conditions)',3),(26,1,'Comment créer un thread en Java ?','-  En étendant la classe Thread -  En implémentant l’interface Runnable',3),(27,1,'Qu’est ce que l’API Stream ?','-  Introduite en Java 8 -  Fonctionnalités pour manipuler des flux de données -  Exemple : List<Integer> numbers = Arrays.asList(1, 2, 3) List<Integer> squares = numbers.stream().map(n -> n * n).collect(Collectors.toList())',3),(28,1,'Qu’est ce qu’un Stream ?','-  Séquence d’éléments permettant d’effectuer des opérations de traitement de manière déclarative et optimisée. -  Code plus concis et lisible',3),(29,1,'Quelles sont les méthodes de l’API Stream ?','-  Filter() -  Map() -  FlatMap() -  Reduce() -  Collect() -  Sorted() -  Distinct() -  ForEach() -  Parallel() -  Anymatch() -  AllMatch()',3),(30,1,'Qu’est ce que JDBC ?','-  Java Database Connectivity -  Pour éxécuter des requetes SQL -  Pour interagir avec une bdd SQL',3),(31,1,'Qu’est ce que l’API Collections ?','-  Fournit des structures de données pour manipuler des collections d’objets -  Principales interfaces : o  List (ordonnée, double autorisé) o  Set (éléments uniques) o  Map (dico clé-valeur) o  Queue (file d’attente)',3),(32,1,'Quels sont les différents types de List ?','-  ArrayList : tableau dynamique, accès rapide, insertion lente. -  LinekdList : liste chainée, accès lent, insertion rapide.',3),(33,1,'Quels sont les différents types de Set ?','-  HashSet : non ordonné, basé sur table de hachage, recherche rapide. -  TreeSet : trié naturellement, basé sur arbre rouge noir, recherche plus lente. -  Linked HashSet : conserve ordre insertion, basé sur HashSet avec liste chainée.  Idem pour Map.',3),(34,2,'Qu’est-ce qu’une table de hachage ?','-  On passe chaque clé dans une fonction de hachage qui la transforme en un index où elle sera stockée.',3),(35,2,'Qu’est-ce qu’un arbre rouge-noir ?','-  Arbre binaire de recherche équilibré pour organiser des données efficacement. -  Garanti une recherche en O(log n) -  Exemple : On recherche 11, on commence à la racine, si plus petit on va à gauche et inversement. On répète à chaque noeud.',3),(36,1,'Quels sont les types de données en Java ?','-  Types primitifs (8) : byte, short, int, long, float, double, char, boolean. -  Types objets (référencés) qui stocke ref vers un emplacement mémoire : String, Array, Class, Interface, Collection...',3),(37,1,'Quelles sont les différentes instructions de contrôle de flux en Java ?','-  If Else -  For loop -  While loop -  Switch',3),(38,2,'Comment est gérée la mémoire en Java ?','-  Gestion automatique de la mémoire grâce au Garbage Collector qui libère la mémoire des objets inutilisés (GC) -  Mémoire divisée en deux parties : o  La Stack (pile) : pour variables locales, ref aux objets, appels méthodes. Mémoire rapide, libérée automatiquement. o  Le Heap (tas) : pour objets crée dynamiquement, objets partagés. Plus lent, le GC en libère l’espace.',3),(39,1,'Quelle différence entre InputStream et Reader ?','-  InputStream pour lire flux d’octet (image) -  Reader pour flux de caractère (unicode)',3),(40,1,'Quelle différence entre String, StringBuilder, StringBuffer ?','-  String : Immutable, modification créer un nouvel objet, thread safe. A utiliser quand ne sera pas modifié. -  StringBuffer : peut être modifié, thread-safe mais pas performant quand multi-thread. -  StringBuilder : Buffer sans synchronisation. Rapide mais pas thread safe.',3),(41,1,'Pourquoi les Strings sont immuables en Java ?','-  Sécurité : pour les url, credentials, chemins... -  Thread-safe -  Performance : pool de chaîne.',4),(42,1,'Qu’est ce que Spring Boot et quels sont les avantages à l’utiliser ?','•  Spring Boot est un framework open source développé par Pivotal, qui s’appuie sur le framework Spring. •  Il facilite la création d’applications Java en proposant : •  Une configuration automatique (auto-configuration). •  Un starter pack de dépendances simplifiant la gestion des librairies. •  Un serveur embarqué (comme Tomcat) pour éviter les déploiements externes. •  Moins de code et de configuration XML. •  Le but : accélérer le développement d’applications Spring, avec un focus sur la productivité et la simplicité.',4),(43,1,'Quelle différence entre Spring Boot et Spring MVC ?','-  Spring MVC : module qui permet de gérer les requêtes HTTP avec le modèle MVC dans Spring. -  Spring Boo : surcouche qui facilite la création d’applications Spring, en automatisant la configuration, notamment de Spring MVC, mais aussi d’autres composants comme la sécurité ou la persistance. Concrètement, Spring Boot utilise souvent Spring MVC pour développer des applications REST, mais en rendant leur mise en place beaucoup plus simple et rapide.',4),(44,1,'Quels sont les principaux éléments de Spring MVC ?','-  DispatcherServlet : le contrôleur central qui reçoit toutes les requêtes HTTP. -  Controller / RestController : classes qui traitent les requêtes (@Controller, @RestController). -  RequestMapping / GetMapping… : annotations pour définir les routes. -  Model : objet qui transporte les données vers la vue. -  ViewResolver : permet de choisir quelle vue (ex : Thymeleaf, JSP) sera utilisée. -  Service : couche métier, logique applicative. -  Repository / DAO : couche d’accès aux données. Résumé : DispatcherServlet dirige la requête vers un Controller, qui utilise éventuellement un Service et un Repository, et renvoie une Vue ou des données (JSON par exemple).',4),(45,1,'Quelle différence entre Spring et Spring Boot ?','Spring Boot est une extension de Spring qui simplifie la création d’applications Spring. Il apporte : -  Auto-configuration (réduction de la configuration manuelle). -  Starters (dépendances prédéfinies). -  Serveur embarqué (Tomcat, Jetty…). -  Démarrage plus rapide, moins de fichiers de configuration. Résumé : Spring = Framework de base. Spring Boot = Simplifie l’utilisation de Spring, avec moins de configuration et un démarrage rapide.',4),(46,1,'Quelles sont les avancées principales des différentes versions de Java ?','-  Java 8 → Lambdas, Streams, Optional. -  Java 9 → Modules. -  Java 10-14 → var, switch expressions, text blocks, records. -  Java 17 (LTS) → Pattern matching, sealed classes. -  Java 19 → Virtual threads (Project Loom), évolution du pattern matching. -  Java 21 (LTS) → Virtual threads stabilisés, sequenced collections, string templates, record patterns.',4),(47,1,'Quelles sont les différentes façons de réaliser l’injection de dependances  ?','-  Par le constructeur (recommandée) -  Par le setter -  Par champ',4),(48,1,'Pourquoi l’injection par constructeur est recommandée ?','•  Garantit que les dépendances sont fournies dès la création de l’objet (immutabilité). •  Rend les dépendances obligatoires et visibles. •  Facilite les tests unitaires (possibilité de passer des mocks). •  Respecte les principes SOLID, notamment l’inversion des dépendances.',4),(49,1,'Quels sont les différents types d’annotations ?','-  De configuration : o  @Configuration : déclare une classe de configuration. o  @Bean : définit un bean dans la configuration. o  @ComponentScan : active la détection automatique des composants.  -  De stéréotype (création de beans) : o  @Component : déclare une classe comme bean. o  @Service : spécialisation de @Component pour la couche service. o  @Repository : spécialisation pour la couche DAO (gestion des exceptions). o  @Controller : pour les contrôleurs web (Spring MVC). o  @RestController : @Controller + @ResponseBody (API REST).  -  Injection de dépendances : o  @Autowired : injection automatique des dépendances. o  @Qualifier : précise quel bean injecter si plusieurs candidats. o  @Value : injecte une valeur (ex : depuis application.properties).  -  Gestion des requêtes : o  @RequestMapping : mappe une URL sur une méthode. o  @GetMapping, @PostMapping, @PutMapping, @DeleteMapping : raccourcis de @RequestMapping. o  @PathVariable, @RequestParam, @RequestBody : récupération des données de la requête.',4),(50,1,'Quelle différence entre @Component et @Bean ?','-  @Component : niveau classe -  @Bean : niveau méthode',4),(51,1,'Qu’est-ce qu’un Bean ?','-  Concept central dans le framework Spring -  Objet instancié, configuré et géré par le conteneur Spring.',4),(52,1,'Qu’est ce que Spring Data JPA ?','Spring Data JPA est un module de Spring qui simplifie l’accès aux bases de données relationnelles en utilisant JPA (Java Persistence API). Il permet de : •  Gérer les entités avec Hibernate ou un autre provider JPA. •  Créer des repositories sans implémentation manuelle •  Générer automatiquement les requêtes avec des méthodes comme findById(), findByName(). Objectif : réduire le code boilerplate pour les opérations CRUD et simplifier l\'interaction avec la base de données.',4),(53,1,'Quels sont les repository fourni par DATA JPA ?','-  CrudRepository : operations CRUD -  PagindAndSortingRepository : CRUD + findAll() avec retour paginé -  JPARepository = CrudRepo + PagingRepo',4),(54,1,'Qu’est ce qu’un Virtual Thread ?','-  thread léger géré par la JVM plutôt que par le système d\'exploitation. -  permet de gérer efficacement un grand nombre de tâches concurrentes, surtout dans des applications avec de nombreuses opérations d\'entrées/sorties. -  plus légers que les threads classiques, ce qui améliore la scalabilité et les performances sans surcharger le système.',4),(55,1,'Qu’est ce qu’une API REST et comment en créer une avec Spring ?','-  API = application programming interface -  REST = representational state transfer -  Style architectural pour créer des interfaces entre un client et un serveur, souvent utilisé pour operations CRUD sur données. -  Avec Spring : o  Déclarer controlleur avec @RestController o  Créer un service métier avec @Service o  Créer un repository qui étend JpaRepository',4),(56,1,'Quels sont les contraintes à suivre pour une API REST ?','-  Stateless : requetes contient toutes les données nécessaires, pas de session. -  Interface uniforme : get, post, patch... -  Cacheable : req peut être mise en cache -  Client-serveur : séparation claire -  Layered System : possibilité d’avoir des intérmédiaires (proxy, load balancer...).',4),(57,1,'Comment gérer les erreurs dans une API REST avec Spring Boot ?','Il existe différentes manières de le faire : -  Bloc try catch dans le controleur -  @ExceptionHandler permet de capturer et gérer exceptions spécifiques dans un controleur donné. -  @ControllerAdvice permet gestion globale des erreurs. -  ResponseEntity permet de renvoyer les bons codes Http avec entetes et corps perso.',4),(58,1,'Comment configurer la connexion avec une bdd relationnelle ?','-  Configurer dans application.properties (id de connection...) -  Définir l’entité avec @Entity et faire correspondre attribut avec colonnes de la table -  Créer un @Repository qui étend JpaRepository',4),(59,1,'A quoi sert Spring Boot Actuator ?','-  Outils pour le monitoring -  Expose des endpoints : /actuactor/health, /info, /metrics',4),(60,1,'Comment mettre en place une pagination ?','-  Utiliser le repository PagingAndSortingRepository ou JpaRepository -  Dans le controleur : @GetMapping(“/users”) Public Page<User> getUsers(Pageable pageable) { Return userRepository.findAll(pageable); }',4),(61,1,'Comment configurer le cache dans une app Spring ?','-  Ajouter spring-boot-stater-cache dans les dependances -  Ajouter @EnableCaching dans le main -  Dans les services : @Cacheable(“nom_données”) devant les méthodes de recup de données que l’on veut mettre en cache. -  Configuration dans application.properties : spring.cache.type = simple (par ex)',4),(62,1,'Comment planifier des tâches ?','-  @EnableScheduling dans le main -  @Scheduled que l’on peut utiliser de 3 façons : o  @Scheduled( fixedRate = 5 000 ) pour une tâche toutes les 5 secondes o  @Scheduled( fixedDelay = 5 000 ) pour que la nouvelle tâche s’exécute 5 secondes après la fin de celle d’avant. o  @Scheduled(cron = 0 0 9 * * * ) pour une tâche tous les jours à 9h (par ex).',4),(63,1,'Qu’est-ce qu’un @Qualifier ?','Pour choisir quel bean injecter quand plusieurs implémentations du même type existent.',4),(64,1,'A quoi sert @Transactional ?','-  En test : annuler en bdd les modifs créées par le test -  Hors test : démarre une transaction en base. Si une exception se produit, toutes les opérations sont rollbackées.',4),(66,1,'Qu’est ce qu’Angular ?','Angular est un framework front-end open source, développé par Google, qui permet de créer des applications web dynamiques et structurées. •  Basé sur TypeScript. •  Utilise des composants, des services et des modules pour organiser le code. •  Supporte le data binding (liaison de données) et la détection des changements. •  Fournit un système de routing pour gérer la navigation entre les pages. •  Intègre des outils pour les tests, la sécurité et l’optimisation des performances. Résumé : Angular = Framework complet pour développer des applications web côté client avec TypeScript, structuré autour de composants et services.',5),(67,1,'Quelle différence entre Angular et AngularJS ?','AngularJS est la première version du framework (2010), basé sur JavaScript et l’architecture MVC, avec du two-way data binding et une manipulation directe du DOM. Angular (à partir de la version 2, en 2016) est une refonte complète, basée sur TypeScript et une architecture par composants, avec une meilleure gestion des performances, de l’injection de dépendances, du routing et de la compilation. Résumé : AngularJS = ancienne version en JavaScript, MVC. Angular = nouvelle génération en TypeScript, composants, plus performant et moderne.',5),(68,1,'Quels sont les avantages d’utiliser Angular ?','-  Basé sur les composants (moins de boiler plate, reutilisation de code facilité) -  Basé sur TypeScript (OOP, maintenabilité) -  All-in-one package (forms, router, material...) -  SPA -  PWA',5),(69,1,'Comment utiliser les directives ?','-  Instructions utilisées dans les templates pour ajouter des fonctionnalités aux élements html. -  Il en existe 3 types : o  Structurelle : *ngIf, *ngFor o  D’attribut : [ngClass], [ngStyle] o  Composant : <app-header></app-header>',5),(70,1,'Comment une app Angular 2.0 fonctionne sur un navigateur ?','-  Les navigateurs ne supportent pas Typescript -  Transpilation nécessaire ( --> JS) -  Ts.config.json contient les infos pour le transpondeur',5),(71,2,'Quelle différence entre compilation et transpilation ?','-  Compilation : language de haut niveau vers code compréhensible par la machine -  Transpilation : languare haut niveau vers autre language de haut niveau.',5),(72,1,'Qu’est ce que le data binding ?','-  Permet de relier l’UI et la logique de l’application. -  Plusieurs types : o  Interpolation : {{ data }}, composant --> vue o  Property binding : [property] = “expression”, composant --> vue o  Event binding : (event) = “handler()”, vue --> composant o  2 way binding : [(ngModel)] = “property”, vue <-- --> composant.',5),(73,1,'Quels sont les différents types de formulaires ?','-  Template-driven form : déclaré dans le template, simple :  <form #myForm=\"ngForm\" (ngSubmit)=\"onSubmit(myForm)\"> <input type=\"text\" name=\"firstName\" ngModel required> <input type=\"email\" name=\"email\" ngModel required> <button type=\"submit\" [disabled]=\"!myForm.valid\">Submit</button> </form>  -  Reactive form : déclaré dans le ts avec FormGroup, FormControl, complexe.  Expliquer le cycle de vie d’un composant Angular. Le cycle de vie d\'un composant Angular suit un ensemble de hooks qui sont appelés à différentes étapes du processus de création, mise à jour et destruction d\'un composant. Voici les étapes principales : -  ngOnChanges : Appelé lorsque les propriétés liées à des bindings changent (avant ngOnInit). -  ngOnInit : Appelé une fois après la première initialisation des inputs du composant. -  ngDoCheck : Appelé lors de chaque changement de détection. Permet de réaliser des vérifications personnalisées. -  ngAfterContentInit : Appelé après l\'insertion du contenu projeté dans le composant (avec ng- content). -  ngAfterContentChecked : Appelé après chaque changement de détection dans le contenu projeté. -  ngAfterViewInit : Appelé après l\'initialisation de la vue du composant et de ses vues enfants. -  ngAfterViewChecked : Appelé après chaque changement de détection dans la vue du composant et ses vues enfants. -  ngOnDestroy : Appelé juste avant la destruction du composant, utile pour effectuer des nettoyages. Chaque hook peut être implémenté pour gérer des actions spécifiques à chaque étape du cycle de vie du composant.',5),(74,1,'Quelle différence entre le constructeur et ngOnInit ?','-  Constructeur : pour injection de dépendances -  NgOnInit : pour initier des données ou appel asynchrone.',5),(75,1,'Quelles sont les nouveautés d’Angular 17 ?','-  Nouveau control flow ( @if, @for) -  @defer -  ESBuild et vite -  SSR par défaut  Grandes nouveautés par version d’Angular ? -  5 : PWA, HttpClient -  6 : Angular Material -  14 : composant autonome -  19 : dernière version, nov 2024',5),(76,1,'Comment fonctionne la détection de changement ?','-  CheckAlways par défaut : Angular vérifie chaque composant dans l\'arborescence des composants, indépendamment de s\'il a changé ou non, couteux en perf -  Passer a OnPush pour améliorer perf : la verif se fait quand un @Input change, un event est émis ou un obs émet une valeur.',5),(77,1,'Quelle différence entre Subject et BehaviourSubject ?','-  Subject n’émet une valeur qu’à partir du moment ou il y a un abonné. Stocke pas la dernière valeur donc si on s’abonne après émission on reçoit rien. -  Behaviour : nécessite une valeur de départ, émet dernière valeur a tout nouvel abonné.',5),(78,1,'Comment fonctionne le routing dans Angular ?','-  Définir les routes dans app.routes.ts ou dans AppRoutingModule suivant si on est en composant standalone ou non. -  Fournir les routes dans les providers de bootstrapApplication : provideRouter(routes) -  Mettre la balise dans le template principal : <router-outlet></router-outlet> -  2 manières de naviguer : o  Dans le template : [routerLink]=”[‘/home’]’ o  Dans le typescript : this.router.navigate([‘/home’])',5),(79,1,'Comment passer des paramètres dans une URL en routing ?','-  Définir la route avec paramètre : { path : ‘user/:id’, component : UserComponent } -  Naviguer vers : this.router.navigate([‘user’, 42]) -  Récupérer le paramètre : o  Par observable : this.route.paramMap.subscribe(params => const id = params.get(‘id’)) o  Par snapshot : const id = this.route.snapshot.paramMap.get(‘id’). Pas réactif !',5),(80,1,'Qu’est ce que RxJS ?','-  Reactive Extensions for javascript -  Bibliothèque pour programmation réactive basée sur les observables.',5),(81,1,'Qu’est ce qu’un observable ?','-  Objet qui représente une suite de données asynchrones -  Paresseux : rien ne se passe tant qu’on ne s’y abonne pas',5),(82,1,'Quelle difference entre observable et promise ?','-  Observable : émission multiple, operateurs, contrôle du flux. -  Promise : émission unique, pas d’opérateurs.',5),(83,1,'En RxJS, que fait pipe() ?','-  Permet de chainer des opérateurs pour transformer valeur émise par observable.',5),(84,1,'Quels sont les principaux operateurs RxJS ?','-  De transformation : o  Map : transforme chaque valeur o  SwitchMap : annule précédent obs et en lance un nouveau o  MergeMap : plusieurs obs en parallèle o  ConcatMap : file d’attente d’obs o  ExhaustMap : ignore nouveaux si un obs déjà en cours  -  De filtrage : o  Filter o  DistinctUntilChanges o  DebounceTime o  Take(n) / TakeUntil  -  Combinatoires : o  ForkJoin : attend que chacun émette o  CombineLatest : dernières val de plusieurs obs o  WithLatestFrom  -  De gestion d’erreur : o  CatchError o  Retry / retryWhen  -  Utilitaires : o  Tap : effet de bord o  Finalise : appelé à la fin  Exemple de pipe champ de recherche :',5),(85,1,'En angular, a quoi servent les pipe (hors RxJS) ?','-  Transforme données dans template sans les modifier dans le composant -  Pour date, currency, uppercase... -  On peut en créer un perso avec @Pipe et implements PipeTransform.',5),(86,1,'Qu’est ce qu’un guard ?','-  Permet de verifier certaines conditions avant d’autoriser une route. -  Types : canActivate, CanActivateChild, CanDeactivate, Resolve, CanLoad. -  On définit le guard en créant une classe qui implémentes CanActivate (par ex) -  On y définit la méthode CanActivate(): boolean { ... } -  Et on l’ajoute dans la route : { Path: ‘account’, component : AccountComponent, canActivate : [NomDuGuard] }',5),(87,1,'Comment utiliser le module HttpClient ?','-  L’importer dans module ou composant -  Injecter dans le constructeur -  Requetes : this.http.get<Bon>(‘url’).subscribe(data => {...} )',5),(88,1,'Comment fonctionne la communication entre composants ?','-  Parent vers enfant : Input o  Dans enfant : @Input() user!: User o  Dans parent : <app-child [user]=”currentUser”>  -  Enfant vers parent : Output + EventEmitter o  Enfant : @Output() deleted = new EventEmitter<number>(); OnDelete() { this.deleted.emit(this.user.id) } o  Parent : <app-child    (deleted) = “OnUserDeleted($event)” >',5),(89,1,'Qu’est ce que “ng-content” ?','-  Balise spéciale pour afficher du contenu externe -  Pour composant réutilisable avec contenu personnalisé -  Si on en met plusieurs il faut donner un nom : <ng-content     select=”[card-header]”>',5),(90,1,'Comment utiliser @ViewChild et @ContentChild ?','-  @ViewChild : accéder à un élément du template (élement html, directive ou enfant) @ViewChild(“id de l’elt”)   elt! : ElementRef ;  -  @ContentChild : accéder au contenu injécté depuis l’exterieur avec ng-content.',5),(91,1,'A quoi sert HttpInterceptor ?','-  Intercepter requêtes partantes pour ajouter des headers, logger, gérer erreurs... -  L’ajouter comme provider',5),(92,1,'Comment fonctionne l’injection de dépendances dans Angular ?','-  Définition du service avec @Injectable() : o  Le décorateur @Injectable() indique à Angular qu\'un service peut être injecté dans d\'autres composants, directives ou services. o  Il permet de spécifier où et comment Angular doit gérer l\'injection du service.  -  Niveaux d’injection : o  providedIn: \'root\' : Le service est global, une seule instance est partagée à travers toute l\'application (singleton). o  providedIn: \'any\' : Le service a une instance par module lazy-loaded. Chaque module chargé paresseusement aura sa propre instance. o  providers dans un composant ou module : L\'injection peut être restreinte à des instances locales spécifiques, par exemple, pour un service spécifique à un composant ou un module.  -  Résolution de l\'injection : o  Quand un service est demandé dans le constructeur d\'une classe, Angular cherche ce service dans l\'injecteur du composant ou service courant. o  Si le service n\'est pas trouvé, Angular remonte dans la hiérarchie des injecteurs (composants parents, modules parents, etc.) jusqu\'à ce qu\'il le trouve ou atteigne le niveau global.  Il se passe quoi si ProvidedIn : root mais présence dans tableau provider d’un composant ? Plus de Singleton car une instance locale est ajoutée.',5),(93,1,'Quelle architecture tu privilégies pour un projet Angular ?','-  Src : o  App ▪  Core (interceptors, guards, auth...) ▪  Shared (composants réutilisables, pipes, directives...) ▪  Features ▪  App.component.ts o  Main.ts o  App.config.ts',6),(94,1,'Quelle différence entre MySQL et PostgreSQL ?','-  MySQL : rapide et simple, quand rapidité en lecture est la clé. -  Postgre : big data, quand robustesse et évolutivité est la clé. Plus respectueuse des standards SQL, + d’extensions, + sécuritaire, + scalable.',6),(95,1,'Qu’est-ce qu’une base de données relationnelle ?','-  Organise les données en tables avec des lignes et des colonnes -  Relations entre les tables sont gérées à l\'aide de clés primaires et étrangères.',6),(96,1,'Qu\'est-ce qu\'un SGBD et quels sont les exemples populaires ?','-  SGBD : Système de Gestion de Base de Données -  Logiciel qui permet de créer, gérer et interagir avec des bases de données. -  Exemples populaires : MySQL, PostgreSQL, Oracle, SQL Server.  Quels sont les avantages d\'utiliser une base de données relationnelle par rapport à une base de données NoSQL ? -  Modèle structuré : Données organisées en tables avec relations claires entre les entités. -  Langage SQL puissant : Permet des requêtes complexes, des jointures et des agrégations avancées. -  Intégrité des données (ACID) : Garantit la cohérence, la fiabilité et la sécurité des transactions. -  Normalisation : Réduction de la redondance et meilleure cohérence des données. -  Support mature : Outils, documentation et communauté très développés. -  Bonne gestion des transactions : Essentiel pour les applications où les opérations doivent être atomiques (par exemple, systèmes bancaires). En résumé, les bases relationnelles sont adaptées aux systèmes avec des relations complexes, des besoins forts en intégrité et des transactions critiques.',6),(97,1,'Qu’est-ce qu’une clé primaire et une clé étrangère ?','-  Clé primaire : Un identifiant unique pour chaque enregistrement dans une table. -  Clé étrangère : Une référence à une clé primaire d\'une autre table, établissant une relation entre les tables.  Qu’est-ce que la normalisation d\'une base de données et pourquoi est-elle importante ? -  Processus de structuration des données pour réduire la redondance et améliorer l\'intégrité des données. -  Permet d\'éviter les anomalies lors des insertions, mises à jour et suppressions.',6),(98,2,'Qu’est-ce que la 1ère, 2ème, 3ème forme normale (1NF, 2NF, 3NF) ?','-  1NF : Les données sont atomiques (chaque colonne contient une seule valeur). -  2NF : La table est en 1NF et toutes les colonnes non-clé dépendent entièrement de la clé primaire. -  3NF : La table est en 2NF et il n\'y a pas de dépendances transitives (pas de dépendance entre colonnes non-clés).  Que sont les dépendances fonctionnelles et comment influencent-elles la normalisation ? -   Dépendance fonctionnelle = décrit une relation où la valeur d\'une colonne dépend de la valeur d\'une autre colonne. -  Elles influencent la normalisation en permettant de diviser les données pour éliminer les redondances.',6),(99,1,'Quelle est la différence entre une requête JOIN interne et une requête JOIN externe ?','-  JOIN interne : Renvoie les enregistrements communs entre les deux tables. -  JOIN externe : Renvoie tous les enregistrements d\'une table et les correspondances de l\'autre, avec des valeurs nulles là où il n\'y a pas de correspondance.  Comment écrirait-on une requête SQL pour sélectionner tous les utilisateurs dont l’âge est supérieur à 30 ? SELECT * FROM utilisateurs WHERE age > 30;',6),(100,1,'Quelle est la différence entre GROUP BY et ORDER BY ?','-  GROUP BY : Regroupe les résultats par une ou plusieurs colonnes pour des agrégations. -  ORDER BY : Trie les résultats par une ou plusieurs colonnes dans un ordre croissant ou décroissant.',6),(101,1,'Qu\'est-ce qu\'une sous-requête et quand l\'utiliser ?','-  Requête imbriquée à l\'intérieur d\'une autre. -  Utilisée pour effectuer une requête sur les résultats d\'une autre requête, -  Souvent pour filtrer ou calculer des valeurs spécifiques.',6),(102,1,'Comment optimiser les performances des requêtes SQL ?','-  Utiliser des index sur les colonnes fréquemment interrogées, -  Écrire des requêtes simples, -  Éviter les sous-requêtes inutiles, -  Utiliser des plans d\'exécution pour analyser la performance des requêtes.',6),(103,1,'Qu’est-ce qu’une base de données NoSQL ?','Une base de données NoSQL est une base de données non relationnelle qui permet de stocker des données dans des formats variés (document, clé-valeur, graphe, colonne), souvent plus flexible et évolutive que les bases relationnelles.',6),(104,1,'Quels sont les types de bases de données NoSQL ?','-  Clé-valeur, -  Document (ex. MongoDB), -  Colonne (ex. Cassandra), -  Graphe (ex. Neo4j).  Quand utiliser une base de données NoSQL plutôt qu’une base de données relationnelle ? -  pour des données non structurées, -  scalabilité horizontale, -  des modèles de données flexibles, -  lorsque les exigences ACID sont moins critiques.',6),(105,2,'Comment gérer les sauvegardes et les restaurations d\'une base de données ?','La gestion des sauvegardes et des restaurations nécessite une planification rigoureuse incluant des sauvegardes complètes et incrémentielles, une automatisation des processus, un stockage sécurisé des sauvegardes, ainsi que des tests réguliers de restauration pour garantir la fiabilité du système en cas de besoin.',6),(106,2,'Qu’est-ce que le clustering en base de données ?','Le clustering est la mise en place de plusieurs instances de bases de données sur différentes machines pour assurer la haute disponibilité, la répartition de charge et la tolérance aux pannes.',7),(107,1,'Qu’est-ce qu’une interface en typeScript et à quoi sert-elle dans un projet Angular ?','-  Définit un contrat de structure -  Un objet/classe qui l’implémente doit respecter les propriétés et types définis. -  Ne contient pas de logique. -  Dans un projet : permet de modeliser des données : o  Export Interface User { Id: number ; Name: string ; Email : string; }',7),(108,1,'Quelle différence entre == et === ?','-  == égalité faible, compare valeur après avoir changé de type si besoin -  === égalité forte, compare valeur + type.',7),(109,2,'Qu’est-ce qu’un mixin ?','Une fonction qui prend une classe comme argument et renvoie une nouvelle classe avec méthodes supplémentaires.',7),(110,1,'Qu’est-ce qu’un decorator ?','-  Fonction d’annotation pour ajouter des métadonnées ou modifier la logique de classes, méthodes, propriétés. -  4 types : o  Class o  Method o  Property o  Parameter -  Exemple : @Component, @Injectable',8),(111,1,'Qu’est ce que le CORS ?','-  Cross Origin Resource Sharing -  Mécanisme de sécurité des navigateurs qui bloque les appels http entre origines différentes.',8),(112,1,'Comment on le gère en Spring/Angular ?','-  Soit directement dans le contrôleur avec @CrossOrigin(origins = “url”) -  Soit globalement dans une config avec http.cors ... setAllowedOrigins, setAllowedHeaders...',8),(113,1,'Quelles sont les bonnes pratiques de sécurité dans une app Spring ?','-  Protocole https -  Stocker données sensibles cryptées -  Authentification solide avec JWT par exemple -  Mise à jour régulières des dépendances -  Role-based control -  Security headers -  Audits réguliers  Expliquer le mécanisme JWT. -  JWT = Json Web Token -  Process : o  User se connecte, credentials valide o  Token généré, signé avec clé secrète o  Il contient username + date expiration + rôles o  Front enregistre token (localstorage ou cookies) o  Front l’envoie avec requêtes dans le header Authorization : Bearer o  Back intercepte requête et vérifie validité token.',9),(114,1,'Qu’est-ce qu’un DTO ?','-  Data transfer object -  Permet de ne pas exposer directement les entités => meilleure sécurité -  Permet de structurer les données différemment pour le front -  Permet une meilleure résilience de l’app en cas de changement de la bdd',10),(115,1,'Qu’est-ce qu’Hibernate ?','-  Framework de mapping objet – relationnel (ORM) qui simplifie les interactions avec bdd. -  Spring DATA JPA l’utilise par default',10),(116,1,'Qu’est ce que Maven ?','-  Outils de gestion de projet qui utilise des fichires de configuration en XML.',10),(117,1,' Expliquer la méthode main en Java.',' -  Porte d’entrée du programme \n-  Public, static, void, String[] en paramètre.',3);
/*!40000 ALTER TABLE `questions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `topics`
--

DROP TABLE IF EXISTS `topics`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `topics` (
  `id` int NOT NULL,
  `name` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `topics`
--

LOCK TABLES `topics` WRITE;
/*!40000 ALTER TABLE `topics` DISABLE KEYS */;
INSERT INTO `topics` VALUES (1,'DEVELOPPEMENT WEB'),(2,'ARCHITECTURE, DESIGN PATTERN'),(3,'JAVA'),(4,'SPRING'),(5,'ANGULAR'),(6,'BASE DE DONNEES'),(7,'TYPESCRIPT'),(8,'SECURITE'),(9,'BONNE PRATIQUES'),(10,'AUTRES');
/*!40000 ALTER TABLE `topics` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `users` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `email` varchar(255) NOT NULL,
  `password` varchar(255) NOT NULL,
  `username` varchar(255) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK6dotkott2kjsp8vw4d0m25fb7` (`email`),
  UNIQUE KEY `UKr43af9ap4edm43mmtq01oddj6` (`username`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` VALUES (1,'alice@example.com','$2a$10$S65MR5uiDNaRO9o8Mk5LT.szwfw6A6AIYCwVv8SsodlQiKOR4EoYq','alice');
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2025-05-17 11:51:05
